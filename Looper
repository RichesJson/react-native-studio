   从源码分析我们知道，android是通过init.rd进程启动的，通过init.rd遍历service后，启动一个zgyote的进程。zgyote在进程创建的时候，调用AndroidRuntime启动Dalvik或Art虚拟机，zgytoe进程创建成功后，创建一个zgyote socket、System Sever以及调用runSelectLoopMode函数进入一个无限循环在前面创建的socket接口上等待ActivityManagerService请求创建新进程。Zygote socket是用于监听SystemServer的请求 。当System Server创建成功，发送指令到zgyote server要求为其fork进程。创建了AMS进程、PMS、AM等一些android系统进程。。因此从Activity中获取到的主线程都是来源于Application持有的myLooper.
试想下。如果在Thread中发送一个message，那么这个message如何找到目标的handler的handleMessage方法？
查看源码以后，我们发现message是一个结构体，该结构体中包含了runnable、handler、Messenger、object、what。
handler在初始化的时候，默认持有Looper。从Looper中取出MessageQueue,当我们要发送一条message消息到目标对象的时候，Handler调用了enqueueMessage的方法，将handler放置到message对象中，同时调用MessageQueue的enqueueMessage方法将message放置到MessageQueue中。而此时我们的Looper通过不断的从消息队列中取出Message，根据Message所对应的线程、handler、what、object找出目标的Handeler,然后将message发送到目标的handler中。handler通过handleMessage，取出message信息。通过取出message后，我们要调用handler.removeCallback的方式将Message从MessageQuque中移除。
